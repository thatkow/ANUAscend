<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ascend Preview</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #111;
        color: #fff;
        overflow: hidden;
      }

      .hidden {
        display: none !important;
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.75);
        padding: 1.5rem;
        backdrop-filter: blur(2px);
        z-index: 10;
      }

      .auth-card {
        background: rgba(18, 18, 18, 0.95);
        border-radius: 1rem;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: min(90vw, 360px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }

      .auth-card h1 {
        font-size: 1.4rem;
        text-align: center;
      }

      .auth-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.95rem;
      }

      .auth-field input {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        padding: 0.65rem 1rem;
        font-size: 1rem;
      }

      .auth-submit {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1rem;
        background: #7ed957;
        color: #111;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .auth-submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(126, 217, 87, 0.3);
      }

      .auth-switch {
        font-size: 0.9rem;
        text-align: center;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        justify-content: center;
        align-items: center;
      }

      .auth-switch button {
        background: none;
        border: none;
        color: #7ed957;
        font-weight: 600;
        cursor: pointer;
        text-decoration: underline;
      }

      .auth-error {
        min-height: 1.25rem;
        color: #ff7a7a;
        text-align: center;
        font-size: 0.85rem;
      }

      .app-header {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 5;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .role-badge {
        padding: 0.4rem 0.85rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.15);
        font-size: 0.8rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .nav-links {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .nav-links a {
        padding: 0.5rem 0.85rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.15);
        color: inherit;
        font-size: 0.8rem;
        text-decoration: none;
        transition: background 0.2s ease;
      }

      .nav-links a:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .sign-out {
        border: none;
        border-radius: 999px;
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
        backdrop-filter: blur(4px);
        transition: background 0.2s ease;
      }

      .sign-out:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .route-tooltip {
        position: fixed;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.75);
        color: #fff;
        padding: 0.75rem 1rem;
        border-radius: 0.75rem;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
        font-size: 0.85rem;
        line-height: 1.4;
        max-width: min(280px, 80vw);
        z-index: 6;
        opacity: 0;
        transform: translate(-50%, -12px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .route-tooltip.pinned {
        pointer-events: auto;
      }

      .route-tooltip.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      .route-tooltip .tooltip-title {
        display: block;
        font-size: 0.95rem;
        font-weight: 600;
      }

      .route-tooltip .tooltip-lines {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        white-space: pre-line;
      }

      .route-tooltip .tooltip-line {
        display: block;
      }

      .ascend-toggle {
        margin-top: 0.75rem;
        width: 100%;
        border: none;
        border-radius: 999px;
        padding: 0.6rem 1rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        background: rgba(126, 217, 87, 0.15);
        color: #7ed957;
      }

      .ascend-toggle:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 18px rgba(126, 217, 87, 0.25);
      }

      .ascend-toggle.ascended {
        background: rgba(126, 217, 87, 0.85);
        color: #111;
      }

      .ascend-status {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 600;
        color: #7ed957;
      }

      .ascend-status::before {
        content: '✔';
        font-size: 0.9rem;
      }

      .ascend-status.not-ascended {
        color: rgba(255, 255, 255, 0.7);
      }

      .ascend-status.not-ascended::before {
        content: '○';
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <div id="authOverlay" class="auth-overlay" role="dialog" aria-modal="true" aria-labelledby="authTitle">
      <form id="authForm" class="auth-card">
        <h1 id="authTitle">Sign in to continue</h1>
        <label class="auth-field">
          <span>Email</span>
          <input id="authEmail" type="email" name="email" autocomplete="email" required />
        </label>
        <label class="auth-field">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="6" required />
        </label>
        <p id="authError" class="auth-error" role="alert" aria-live="assertive"></p>
        <button type="submit" class="auth-submit">Sign In</button>
        <p class="auth-switch">
          <span id="authSwitchLabel">Don't have an account?</span>
          <button type="button" id="toggleAuthMode">Create one</button>
        </p>
      </form>
    </div>
    <div id="appContent" class="app hidden" aria-live="polite">
      <header class="app-header">
        <nav id="navLinks" class="nav-links" aria-label="Available pages">
          <a id="setterLink" class="hidden" href="setter.html">Setter Tools</a>
        </nav>
        <span id="roleBadge" class="role-badge hidden" aria-live="polite"></span>
        <button id="signOutButton" class="sign-out">Sign out</button>
      </header>
      <canvas id="previewCanvas" aria-hidden="true"></canvas>
    </div>
    <div
      id="routeTooltip"
      class="route-tooltip"
      role="status"
      aria-live="polite"
      aria-hidden="true"
    ></div>
    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        deleteDoc,
        serverTimestamp,
        collection,
        getDocs,
        query,
        limit,
      } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';

      const firebaseConfig = {
        apiKey: 'AIzaSyCUKr8bmjIfICZwXDHE7xoaBbAXizJhx3I',
        authDomain: 'anuascend-3f734.firebaseapp.com',
        projectId: 'anuascend-3f734',
        storageBucket: 'anuascend-3f734.firebasestorage.app',
        messagingSenderId: '305441086779',
        appId: '1:305441086779:web:0079c53daf3462bc82eb1e',
        measurementId: 'G-MNT686PF8L',
      };

      const firebaseApp = initializeApp(firebaseConfig);
      const auth = getAuth(firebaseApp);

      const db = getFirestore(firebaseApp);

      const authOverlay = document.getElementById('authOverlay');
      const appContent = document.getElementById('appContent');
      const authForm = document.getElementById('authForm');
      const authEmail = document.getElementById('authEmail');
      const authPassword = document.getElementById('authPassword');
      const authError = document.getElementById('authError');
      const authTitle = document.getElementById('authTitle');
      const authSwitchLabel = document.getElementById('authSwitchLabel');
      const toggleAuthModeButton = document.getElementById('toggleAuthMode');
      const signOutButton = document.getElementById('signOutButton');
      const roleBadge = document.getElementById('roleBadge');
      const setterLink = document.getElementById('setterLink');
      const tooltip = document.getElementById('routeTooltip');

      let authMode = 'login';
      let currentUser = null;
      
      function setAuthMode(mode) {
        authMode = mode;
        const isLogin = authMode === 'login';
        authTitle.textContent = isLogin ? 'Sign in to continue' : 'Create your account';
        authSwitchLabel.textContent = isLogin ? "Don't have an account?" : 'Already have an account?';
        toggleAuthModeButton.textContent = isLogin ? 'Create one' : 'Sign in';
        authForm.querySelector('.auth-submit').textContent = isLogin ? 'Sign In' : 'Create Account';
        authPassword.setAttribute('autocomplete', isLogin ? 'current-password' : 'new-password');
        authError.textContent = '';
      }

      toggleAuthModeButton.addEventListener('click', () => {
        setAuthMode(authMode === 'login' ? 'register' : 'login');
      });

      authForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        authError.textContent = '';
        const email = authEmail.value.trim();
        const password = authPassword.value;

        try {
          if (authMode === 'login') {
            await signInWithEmailAndPassword(auth, email, password);
          } else {
            await createUserWithEmailAndPassword(auth, email, password);
          }
        } catch (error) {
          authError.textContent = error.message;
        }
      });

      signOutButton.addEventListener('click', () => {
        signOut(auth).catch((error) => {
          console.error('Failed to sign out:', error);
        });
      });

      async function ensureUserRole(user) {
        if (!user) {
          return null;
        }

        const roleRef = doc(db, 'roles', user.uid);
        const existingSnap = await getDoc(roleRef);

        if (existingSnap.exists()) {
          return existingSnap.data();
        }

        let role = 'climber';

        try {
          const snapshot = await getDocs(query(collection(db, 'roles'), limit(1)));
          if (snapshot.empty) {
            role = 'setter';
          }
        } catch (error) {
          console.warn('Unable to inspect existing roles:', error);
        }

        const roleData = {
          role,
          email: user.email ?? '',
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        };

        await setDoc(roleRef, roleData);
        return roleData;
      }

      async function resolveUserRole(user) {
        if (!user) {
          return null;
        }

        try {
          const roleRef = doc(db, 'roles', user.uid);
          const roleSnap = await getDoc(roleRef);
          if (roleSnap.exists()) {
            return roleSnap.data().role;
          }

          const createdRole = await ensureUserRole(user);
          return createdRole ? createdRole.role : null;
        } catch (error) {
          console.error('Failed to fetch user role:', error);
          return null;
        }
      }

      function updateNavigationForRole(role) {
        roleBadge.textContent = role ? role.toUpperCase() : '';
        roleBadge.classList.toggle('hidden', !role);

        setterLink.classList.toggle('hidden', role !== 'setter');
      }

      onAuthStateChanged(auth, async (user) => {
        if (user) {
          authOverlay.classList.add('hidden');

          currentUser = user;
          const role = await resolveUserRole(user);

          if (!role) {
            authError.textContent = 'Unable to determine your role. Please try again later.';
            await signOut(auth);
            return;
          }

          updateNavigationForRole(role);
          appContent.classList.remove('hidden');
          await loadAscents(user.email ?? '');
          await loadRoutes();
        } else {
          authOverlay.classList.remove('hidden');
          appContent.classList.add('hidden');
          roleBadge.classList.add('hidden');
          setterLink.classList.add('hidden');
          authForm.reset();
          setAuthMode('login');
          routes = [];
          currentUser = null;
          ascendedRoutes.clear();
          hideTooltip({ force: true });
          redraw();
        }
      });

      setAuthMode('login');

      const canvas = document.getElementById('previewCanvas');
      const ctx = canvas.getContext('2d');

      let routes = [];
      let routePaths = [];
      let activeRouteId = null;
      let pinnedRouteId = null;
      let pinnedPosition = null;
      const ascendedRoutes = new Set();

      async function loadAscents(email) {
        ascendedRoutes.clear();

        if (!email) {
          return;
        }

        try {
          const ascentRef = doc(db, 'ascents', email);
          const ascentSnap = await getDoc(ascentRef);

          if (!ascentSnap.exists()) {
            return;
          }

          const ascentData = ascentSnap.data() ?? {};
          const routesData = ascentData.routes;

          if (routesData && typeof routesData === 'object') {
            Object.entries(routesData).forEach(([routeId, details]) => {
              if (!details) {
                return;
              }

              ascendedRoutes.add(routeId);
            });
            return;
          }

          const singleRouteId = typeof ascentData.route_id === 'string' ? ascentData.route_id : null;
          if (singleRouteId) {
            ascendedRoutes.add(singleRouteId);
          }
        } catch (error) {
          console.error('Failed to load ascents:', error);
        }
      }

      function normalizeDate(value) {
        if (!value) {
          return null;
        }

        if (typeof value === 'string') {
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? null : date.toISOString();
        }

        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }

        if (typeof value?.toDate === 'function') {
          const date = value.toDate();
          if (date instanceof Date && !Number.isNaN(date.getTime())) {
            return date.toISOString();
          }
          return null;
        }

        return null;
      }

      function formatDisplayDate(isoString) {
        if (!isoString) {
          return 'Unknown';
        }

        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return 'Unknown';
        }

        return date.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
        });
      }

      function updateTooltipContent(route) {
        if (!tooltip) {
          return;
        }

        const fragment = document.createDocumentFragment();
        const ariaLines = [];

        const displayTitle = (route.title || route.id || '').trim();
        if (displayTitle) {
          const titleLine = document.createElement('strong');
          titleLine.className = 'tooltip-title';
          titleLine.textContent = displayTitle;
          fragment.appendChild(titleLine);
          ariaLines.push(displayTitle);
        }

        const infoContainer = document.createElement('div');
        infoContainer.className = 'tooltip-lines';
        fragment.appendChild(infoContainer);

        const appendInfoLine = (text, className = '') => {
          if (!text) {
            return;
          }
          const line = document.createElement('div');
          line.className = className ? `tooltip-line ${className}` : 'tooltip-line';
          line.textContent = text;
          infoContainer.appendChild(line);
          ariaLines.push(text);
        };

        const setterValue = typeof route.setter === 'string' ? route.setter : '';
        appendInfoLine(`Setter: ${setterValue.trim() || 'Unknown'}`);

        const descriptionText =
          typeof route.description === 'string' ? route.description.trim() : '';
        appendInfoLine(descriptionText ? `Description: ${descriptionText}` : 'Description: —');

        appendInfoLine(`Date set: ${formatDisplayDate(route.date_set)}`);

        if (ascendedRoutes.has(route.id)) {
          appendInfoLine('Ascended', 'ascend-status');
        } else {
          appendInfoLine('Not ascended', 'ascend-status not-ascended');
        }

        if (currentUser) {
          const actionButton = document.createElement('button');
          actionButton.type = 'button';
          actionButton.className = `ascend-toggle${ascendedRoutes.has(route.id) ? ' ascended' : ''}`;
          actionButton.textContent = ascendedRoutes.has(route.id) ? 'Unmark as ascended' : 'Mark as ascended';
          actionButton.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            toggleRouteAscent(route);
          });
          fragment.appendChild(actionButton);
        }

        tooltip.replaceChildren(fragment);

        if (ariaLines.length) {
          tooltip.setAttribute('aria-label', ariaLines.join('\n'));
        } else {
          tooltip.removeAttribute('aria-label');
        }
      }

      function positionTooltip(clientX, clientY) {
        if (!tooltip) {
          return;
        }

        const tooltipWidth = tooltip.offsetWidth || 0;
        const tooltipHeight = tooltip.offsetHeight || 0;
        const halfWidth = tooltipWidth / 2;

        const minX = halfWidth + 12;
        const maxX = window.innerWidth - halfWidth - 12;
        const desiredLeft = clientX;
        const clampedLeft = maxX < minX ? window.innerWidth / 2 : Math.min(maxX, Math.max(minX, desiredLeft));

        const minTop = 20;
        const maxTop = window.innerHeight - tooltipHeight + 4;
        const desiredTop = clientY - 24;
        const clampedTop = maxTop < minTop ? window.innerHeight / 2 : Math.min(maxTop, Math.max(minTop, desiredTop));

        tooltip.style.left = `${clampedLeft}px`;
        tooltip.style.top = `${clampedTop}px`;
      }

      function showTooltip(route, clientX, clientY, options = {}) {
        if (!tooltip) {
          return;
        }

        const { pin = false } = options;

        if (route.id !== activeRouteId) {
          updateTooltipContent(route);
        }

        const position = { x: clientX, y: clientY };
        positionTooltip(position.x, position.y);
        tooltip.classList.add('visible');
        tooltip.setAttribute('aria-hidden', 'false');
        activeRouteId = route.id;

        if (pin) {
          pinnedRouteId = route.id;
          pinnedPosition = { ...position };
          tooltip.classList.add('pinned');
        } else {
          pinnedRouteId = null;
          pinnedPosition = null;
          tooltip.classList.remove('pinned');
        }
      }

      function hideTooltip(options = {}) {
        if (!tooltip) {
          return;
        }

        const { force = false } = options;

        if (!force && pinnedRouteId) {
          return;
        }

        tooltip.classList.remove('visible');
        tooltip.classList.remove('pinned');
        tooltip.setAttribute('aria-hidden', 'true');
        activeRouteId = null;
        pinnedRouteId = null;
        pinnedPosition = null;
      }

      function getRouteEntryAtClientPoint(clientX, clientY) {
        if (!routePaths.length) {
          return null;
        }

        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        for (let index = routePaths.length - 1; index >= 0; index -= 1) {
          const entry = routePaths[index];
          const previousLineWidth = ctx.lineWidth;
          ctx.lineWidth = entry.lineWidth;
          const isInside = ctx.isPointInStroke(entry.path, x, y);
          ctx.lineWidth = previousLineWidth;

          if (isInside) {
            return entry;
          }
        }

        return null;
      }

      function extractClientPoint(event) {
        if (typeof event.clientX === 'number' && typeof event.clientY === 'number') {
          return { x: event.clientX, y: event.clientY };
        }

        const touch = event.touches?.[0] ?? event.changedTouches?.[0];
        if (touch) {
          return { x: touch.clientX, y: touch.clientY };
        }

        return null;
      }

      async function loadRoutes() {
        try {
          const snapshot = await getDocs(collection(db, 'routes'));
          routes = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data();
              const normalizedPoints = Array.isArray(data.points)
                ? data.points
                    .map((point) => {
                      const x = Number(point?.x);
                      const y = Number(point?.y);
                      if (!Number.isFinite(x) || !Number.isFinite(y)) {
                        return null;
                      }
                      return { x, y };
                    })
                    .filter(Boolean)
                : [];

              return {
                id: docSnap.id,
                strokeColor: typeof data.strokeColor === 'string' ? data.strokeColor : '#ffde59',
                points: normalizedPoints,
                title: typeof data.title === 'string' ? data.title : '',
                setter: typeof data.setter === 'string' ? data.setter : '',
                description: typeof data.description === 'string' ? data.description : '',
                date_set: normalizeDate(data.date_set),
                date_removed: normalizeDate(data.date_removed),
              };
            })
            .sort((a, b) => {
              const nameA = (a.title || a.id).toLowerCase();
              const nameB = (b.title || b.id).toLowerCase();
              return nameA.localeCompare(nameB);
            });

          redraw();
        } catch (error) {
          console.error('Failed to load routes:', error);
          routes = [];
          redraw();
        }
      }

      async function toggleRouteAscent(route) {
        if (!currentUser) {
          return;
        }

        const email = currentUser.email;
        if (!email) {
          console.warn('Unable to mark ascent: user email missing.');
          return;
        }

        const routeId = route.id;
        const ascentRef = doc(db, 'ascents', email);
        const isAscended = ascendedRoutes.has(routeId);

        try {
          if (isAscended) {
            let remainingRoutes = {};

            try {
              const ascentSnap = await getDoc(ascentRef);
              if (ascentSnap.exists()) {
                const ascentData = ascentSnap.data() ?? {};
                const currentRoutes =
                  ascentData.routes && typeof ascentData.routes === 'object' ? { ...ascentData.routes } : {};
                delete currentRoutes[routeId];
                remainingRoutes = currentRoutes;
              }
            } catch (loadError) {
              console.warn('Unable to load existing ascents before removal:', loadError);
            }

            if (Object.keys(remainingRoutes).length === 0) {
              await deleteDoc(ascentRef);
            } else {
              await setDoc(ascentRef, {
                climber_email: email,
                updatedAt: serverTimestamp(),
                routes: remainingRoutes,
              });
            }
            ascendedRoutes.delete(routeId);
          } else {
            await setDoc(
              ascentRef,
              {
                climber_email: email,
                updatedAt: serverTimestamp(),
                routes: {
                  [routeId]: {
                    route_id: routeId,
                    date_ascended: new Date().toISOString(),
                    climber_email: email,
                  },
                },
              },
              { merge: true },
            );
            ascendedRoutes.add(routeId);
          }

          updateTooltipContent(route);
          redraw();
        } catch (error) {
          console.error('Failed to update ascent:', error);
        }
      }

      const backgroundImage = new Image();
      let backgroundReady = false;

      backgroundImage.src = 'background.png';
      backgroundImage.onload = () => {
        backgroundReady = true;
        resizeCanvas();
      };

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        redraw();
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (backgroundReady) {
          ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        routePaths = [];
        const shouldPreservePinned = Boolean(pinnedRouteId && pinnedPosition);
        const pinnedRoute = shouldPreservePinned
          ? routes.find((route) => route.id === pinnedRouteId)
          : null;

        if (!shouldPreservePinned) {
          hideTooltip();
        } else if (!pinnedRoute) {
          hideTooltip({ force: true });
        }

        routes.forEach(drawRoute);

        if (pinnedRoute && tooltip) {
          updateTooltipContent(pinnedRoute);
          tooltip.classList.add('visible');
          tooltip.classList.add('pinned');
          tooltip.setAttribute('aria-hidden', 'false');
          positionTooltip(pinnedPosition.x, pinnedPosition.y);
        }
      }

      function drawRoute(route) {
        const strokeColor = typeof route.strokeColor === 'string' ? route.strokeColor : '#ffde59';
        const points = Array.isArray(route.points) ? route.points : [];

        if (points.length < 2) {
          return;
        }

        const scaledPoints = points
          .map((point) => {
            const x = Number(point?.x);
            const y = Number(point?.y);
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
              return null;
            }
            return {
              x: x * canvas.width,
              y: y * canvas.height,
            };
          })
          .filter(Boolean);

        if (scaledPoints.length < 2) {
          return;
        }

        const path = new Path2D();
        path.moveTo(scaledPoints[0].x, scaledPoints[0].y);

        for (let i = 0; i < scaledPoints.length - 1; i++) {
          const p0 = i === 0 ? scaledPoints[0] : scaledPoints[i - 1];
          const p1 = scaledPoints[i];
          const p2 = scaledPoints[i + 1];
          const p3 = i + 2 < scaledPoints.length ? scaledPoints[i + 2] : scaledPoints[i + 1];

          const cp1x = p1.x + (p2.x - p0.x) / 6;
          const cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6;
          const cp2y = p2.y - (p3.y - p1.y) / 6;

          path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }

        const lineWidth = 10;
        const anchorIndex = Math.floor(scaledPoints.length / 2);
        const anchor = scaledPoints[anchorIndex];
        const radius = Math.max(12, canvas.width * 0.01);
        const gapRadius = anchor ? Math.max(0, radius - lineWidth / 2) : 0;

        ctx.save();
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeColor;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        if (anchor && gapRadius > 0) {
          ctx.beginPath();
          ctx.rect(0, 0, canvas.width, canvas.height);
          ctx.moveTo(anchor.x + gapRadius, anchor.y);
          ctx.arc(anchor.x, anchor.y, gapRadius, 0, Math.PI * 2);
          ctx.clip('evenodd');
        }

        ctx.stroke(path);
        ctx.restore();

        routePaths.push({
          route,
          path,
          lineWidth,
        });

        if (ascendedRoutes.has(route.id)) {
          ctx.save();
          ctx.fillStyle = strokeColor;
          ctx.globalAlpha = 0.92;
          ctx.beginPath();
          ctx.arc(anchor.x, anchor.y, radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.globalAlpha = 1;
          ctx.strokeStyle = '#111';
          ctx.lineWidth = Math.max(2, radius * 0.18);
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(anchor.x - radius * 0.45, anchor.y + radius * 0.1);
          ctx.lineTo(anchor.x - radius * 0.15, anchor.y + radius * 0.45);
          ctx.lineTo(anchor.x + radius * 0.5, anchor.y - radius * 0.35);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.save();
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = strokeColor;
          ctx.beginPath();
          ctx.arc(anchor.x, anchor.y, radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }

      function handlePointerMove(event) {
        if (pinnedRouteId) {
          return;
        }

        if ('pointerType' in event) {
          const pointerType = event.pointerType;
          if (pointerType && pointerType !== 'mouse' && pointerType !== 'pen') {
            hideTooltip();
            return;
          }
        }

        const entry = getRouteEntryAtClientPoint(event.clientX, event.clientY);

        if (entry) {
          showTooltip(entry.route, event.clientX, event.clientY);
          return;
        }

        hideTooltip();
      }

      function handlePointerLeave() {
        if (pinnedRouteId) {
          return;
        }

        hideTooltip();
      }

      function handleCanvasPointerDown(event) {
        const point = extractClientPoint(event);
        if (!point) {
          return;
        }

        const entry = getRouteEntryAtClientPoint(point.x, point.y);

        if (entry) {
          showTooltip(entry.route, point.x, point.y, { pin: true });
        } else {
          hideTooltip({ force: true });
        }
      }

      function handleDocumentPointerDown(event) {
        if (!tooltip) {
          return;
        }

        if (event.target === canvas) {
          return;
        }

        if (tooltip.contains(event.target)) {
          return;
        }

        hideTooltip({ force: true });
      }

      if ('PointerEvent' in window) {
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerleave', handlePointerLeave);
        canvas.addEventListener('pointerdown', handleCanvasPointerDown);
        document.addEventListener('pointerdown', handleDocumentPointerDown);
      } else {
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseleave', handlePointerLeave);
        canvas.addEventListener('mousedown', handleCanvasPointerDown);
        canvas.addEventListener('touchstart', handleCanvasPointerDown);
        document.addEventListener('mousedown', handleDocumentPointerDown);
        document.addEventListener('touchstart', handleDocumentPointerDown);
      }

      window.addEventListener('resize', resizeCanvas);

      if (backgroundImage.complete) {
        backgroundReady = true;
        resizeCanvas();
      } else {
        resizeCanvas();
      }
    </script>
  </body>
</html>
